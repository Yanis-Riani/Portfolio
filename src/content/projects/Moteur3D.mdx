---
title: Moteur de Rendu 3D Simplifi√©
description: Pr√©sentation d'un moteur de rendu 3D bas√© sur des techniques fondamentales et avanc√©es en programmation graphique, avec une approche p√©dagogique pour rendre les concepts accessibles.
date: "2023-01-16"
repository: Yanis-Riani/Fundamentals3DRender
published: true
---

# Introduction

Ce moteur de rendu 3D est un projet complexe visant √† cr√©er des sc√®nes tridimensionnelles informatiques.\
Il combine plusieurs techniques de la programmation graphique, depuis le dessin de lignes et formes simples jusqu'√† la simulation de l'illumination et de textures sur des objets 3D.

Chaque √©tape est expliqu√©e pour rendre les concepts compr√©hensibles m√™me pour ceux qui n'ont pas une expertise en graphisme informatique.

## Contexte du Projet

Initialement con√ßu comme une s√©rie de travaux pratiques, ce projet est n√© dans le contexte acad√©mique du BUT Informatique Graphique au Puy en Velay, un cursus mettant l'accent sur la 3D.\
L'objectif √©tait d'acqu√©rir une compr√©hension fondamentale de la programmation 3D, en abordant des concepts cl√©s et des techniques essentielles, tout en renfor√ßant notre ma√Ætrise du langage Python.

## Ambition du Projet

L'ambition de ce projet √©tait double: d'une part, apprendre et comprendre les bases de la 3D sur ordinateur, et d'autre part, approfondir notre connaissance en Python.\
√Ä travers ce projet, nous avons explor√© comment les objets 3D sont construits, manipul√©s et rendus, en acqu√©rant une compr√©hension approfondie des processus impliqu√©s.

## Outils & Technologies Utilis√©s

<TechStack technologies={[
  { logo: 'logos-python', name: 'Python', description: "Langage de programmation principal utilis√© pour le d√©veloppement du moteur de rendu 3D." },
  { logo: 'custom-tkinter', name: 'Tkinter', description: "Biblioth√®que utilis√© pour cr√©er l'interface graphique de l'application et g√©rer les interactions utilisateur." },
  { logo: 'custom-pil', name: 'PIL', description: "Biblioth√®que pour le traitement d'images, utilis√©e pour manipuler et afficher les images et textures dans le moteur de rendu." },
]} />

# Fondations: Trac√© Algorithmique

## La Base: Dessiner Lignes et Formes

Le projet commence par le fondamental de tout graphisme informatique: le trac√© de lignes et de formes.\
Des algorithmes sp√©cifiques, tels que ceux de Bresenham et du point milieu, sont utilis√©s pour cette t√¢che. Ils permettent de d√©terminer quels pixels sur un √©cran doivent √™tre allum√©s pour former une ligne ou une forme.\
Imaginez dessiner un point √† chaque pas jusqu'√† former une ligne compl√®te - c'est le principe de base de ces algorithmes.

```python
# Exemple simplifi√© de trac√© de ligne horizontale
class Horizontale(Courbe):     
    def ajouterControle(self, point):
        """ Ajoute un point de controle a l'horizontale.
        Ne fait rien si les 2 points existent deja. """
        if len(self.controles) < 2:
            Courbe.ajouterControle(self, point)

    def dessinerPoints(self, dessinerPoint):
        """ Dessine la courbe. Redefinit la methode de la classe mere. """
        if len(self.controles) == 2 :
            x1 = self.controles[0][0]
            x2 = self.controles[1][0]
            y = self.controles[0][1]
            xMin = min(x1,x2)
            xMax = max(x1, x2)
            for x in range(xMin, xMax):
                dessinerPoint((x, y),(0,0,0))
```

## Architecture MVC pour l'Organisation

Le projet utilise l'architecture Mod√®le-Vue-Contr√¥leur (MVC).\
Cette m√©thode divise l'application en trois parties interconnect√©es: le mod√®le g√®re les donn√©es et la logique, la vue s'occupe de l'affichage, et le contr√¥leur fait le lien entre le mod√®le et la vue.\
Cette s√©paration facilite la gestion du projet et rend le code plus clair.

# √âvolution: Remplissage et Affichage en 3D

## Du Simple au Complexe: Remplissage de Triangles

Apr√®s avoir ma√Ætris√© le trac√© de lignes, le projet √©volue vers le remplissage de formes, en commen√ßant par les triangles.\
Le triangle est la forme de base en 3D en les combinant, on peut cr√©er n'importe quelle surface.\
Le remplissage de triangles est donc une √©tape cruciale pour construire des objets 3D.

```python
# Exemple de la classe pour le remplissage de triangles
class TriangleRempli(Courbe):
    # ...
```

## Visualisation en Fil de Fer

La visualisation en fil de fer est une technique o√π seules les ar√™tes des objets 3D sont dessin√©es, comme un maillage.\
Elle est utile pour comprendre la structure d'un objet 3D sans √™tre submerg√© par les d√©tails.\
Pour cela, l'algorithme du point milieu est utilis√©, offrant une m√©thode efficace pour relier les points dans l'espace 3D.

```python
# Extrait montrant la gestion des fichiers .sce et .obj
class Donnees_scene():
    # ...
```

# Perfectionnement: Algorithme du Peintre et Gestion de la Profondeur

## Passage au R√©alisme: Algorithme du Peintre

L'algorithme du peintre est un pas vers un rendu plus r√©aliste.\
Contrairement √† la visualisation en fil de fer, il permet de remplir les surfaces des objets 3D, en utilisant des couleurs et des ombres pour donner une impression de profondeur et de r√©alit√©.

```python
# Exemple d'utilisation de TriangleRempli avec l'algorithme du peintre
class TriangleRempli():
    # ...
```

## Z-Buffer: G√©rer Qui Est Devant Qui

Une probl√©matique en 3D est de d√©terminer quel objet doit √™tre affich√© devant un autre. Le Z-Buffer est une solution √† ce probl√®me.\
Il s'agit d'une grille o√π chaque case correspond √† un pixel √† l'√©cran et contient l'information de profondeur.\
Ainsi, on peut savoir quel objet doit appara√Ætre devant un autre.

```python
# Exemple de la classe ZBuffer pour la gestion de la profondeur
class ZBuffer():
    def __init__(self) :
        self.zbuffer=[]
        self.dimx=0
        self.dimy=0
         
         
    def alloc_init_zbuffer(self,larg, haut):
        """initialisation du z-buffer"""
        self.zbuffer=[[] for i in range(larg)]
        self.dimx=larg
        self.dimy=haut
        for i in range(larg):
            col=haut*[100000]
            self.zbuffer[i]=col
            
    def acces(self,i,j):
        return self.zbuffer[i][j]
    
    def modif(self,i,j,val):
        self.zbuffer[i][j]=val
```

# Avanc√©es: Illumination et Texturation

## Illumination avec Phong

Le mod√®le d'illumination de Phong est utilis√© pour simuler comment la lumi√®re interagit avec les surfaces des objets.\
Il combine l'illumination ambiante (lumi√®re globale), diffuse (r√©flexion mat) et sp√©culaire (reflets brillants) pour donner un aspect plus naturel et r√©aliste aux objets 3D.

```python
# Calcul de la couleur selon Phong
def calculercouleur(self, M3D, scene):
    # ...
```

## Texturation: Ajouter des D√©tails

La texturation consiste √† appliquer des images 2D sur les surfaces des objets 3D pour ajouter des d√©tails comme des motifs ou des couleurs.\
Cela enrichit visuellement les objets sans alourdir le calcul n√©cessaire pour les cr√©er.

```python
# Application de textures sur les objets 3D
def interpoltriangle_avectexture(self, P1, P2, P3, T1, T2, T3, M3D):
    # ...
```
# Comp√©tences D√©velopp√©es

- üìê **Conception 3D**
- üêç **Programmation Python**
- üñ•Ô∏è **Rendu 3D**
- üß† **R√©solution de probl√®mes**
- üëÅÔ∏è **Perception spatiale**
- üîÑ **Adaptabilit√©**

# Conclusion

Ce projet de moteur de rendu 3D est un assemblage complexe de techniques graphiques, allant du trac√© de lignes simples √† la simulation d'illumination et de texturation sur des objets 3D.


En r√©trospective, bien que le projet ait atteint ses objectifs initiaux, une exploration plus pouss√©e de l'optimisation des performances et de l'int√©gration de fonctionnalit√©s interactives aurait pu enrichir davantage l'exp√©rience utilisateur.\
Ce travail a √©t√© un formidable terrain d'apprentissage, mettant en √©vidence l'importance de l'organisation du code et de la gestion efficace des ressources en Programmation graphique.


Le projet est accessible sur <a href="https://github.com/Yanis-Riani/Fundamentals3DRender" target="_blank">GitHub</a> et je vous invite √† le consulter pour une exp√©rience plus compl√®te.
